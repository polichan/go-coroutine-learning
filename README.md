# go-coroutine-learning
GO 语言协程知识点学习笔记

#### 协程？

协程并不是 GO 语言特有的机制，像 Lua、Ruby、Python、Kotlin、C/C++ 也都有协程的支持。区别在于有些是从语言层面支持，有的通过插件类库支持。Go 语言的协程是原生语言层面支持的。

#### 协程和进程和线程的对比

##### 进程：

* 进程是系统资源分配的最小单位。进程的创建和销毁都是系统资源级别。操作起来代价昂贵。程是抢占式调度，分为三个状态：等待态、就绪态、运行态。进程之间是相互隔离的，拥有各自的系统资源，更加安全。因此存在进程之间通讯不方便的问题

* 进程是线程的载体容器，多个线程除了共享进程的资源还拥有自己的一少部分独立的资源。因此相比进程而言线程更加清凉，进程内的多个线程间的通信比进程容易，但也同样带来了同步和互斥的问题和线程安全的问题（多线程编程的常见问题），尽管多线程编程仍然是当前服务端编程的主流，线程也是 CPU 调度的最小单位，多线程运行时存在线程切换的问题，其状态的转移如图：

##### 协程：

* 协程在有的资料中成为微线程或者用户态轻量级线程，协程调度不需要系统内核参与而是完全由用户态程序来决定，因此协程对于系统而言是无感知的。协程由用户态控制就不存在抢占式调度。抢占式调度会强制让 CPU 控制权切换到其它进线程，多个协程进行协作实调度，协程自己主动把控制权转让出去后，其它协程 才能被执行到，这样就避免了系统切换开销提高了 CPU 的使用效率。

##### 抢占式调度和协作式调度的简单对比图：
![抢占式调度和协作式调度的简单对比图](图片地址)


##### 如何启用一个 Go 协程？

启用一个 Go 协程非常简单，只需要在函数前加上关键字 ``go``，就可以轻易的启用一个新的 Go 协程并发运行。

```golang
package main

import "fmt"

func main() {
	go hello()
	fmt.Println("main function")
}

func hello()  {
	fmt.Println("Hello goroutine")
}
```

 ``go hello()`` 此处启动了一个协程，因此``hello()`` 函数会与 ``main()`` 函数并发执行。``main()`` 函数会运行在一个特有的 Go 协程上，它被称为 Go 的主协程（Main Goroutine)。

 运行结果大概率如下：

```
main function

Process finished with exit code 0
```

为什么只输出了 ``main function`` ？我们的 ``Hello goroutine`` 为什么没有输出呢？

* 当启动一个新的协程时，协程的调用会立即返回，与函数不同，程序控制不回去等待 Go 的协程执行完毕，在本例中即 ``hello()`` 函数，因此程序控制会立即返回到代码的下一行，即 ``fmt.Println("main function")`` ，忽略该协程的任何返回值
* 协程的存在与否取决于 ``main()`` 主协程是否存活，如果主协程被销毁（即程序终止了），那么其余用 go 关键字启用的协程，在本例中为 ``go hello()`` 协程也被销毁了。这就导致了主协程已经节数，但没有完全等待 ``hello()`` 协程的执行完毕，就被销毁了。因此出现了以上情况。

看到这里，你应该知道为什么运行结果是大概率如下，因为主协程和协程的执行顺序是不一致的，在一定概率下，即主协程正好等到了协程的执行完毕，会输出 ``Hello goroutine``。

让我们来修复下这个问题吧！

```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	go hello()
	time.Sleep(1 * time.Second)
	fmt.Println("main function")
}

func hello()  {
	fmt.Println("Hello goroutine")
}
```

可以看到，我们利用 ``time`` 包中的  ``Sleep`` 方法，去休眠主协程，让其等待 1 秒钟，等待 ``hello()`` 协程执行完毕。那么最终输出结果如下：

```
Hello goroutine
main function

Process finished with exit code 0
```
``注意``：在实际业务中，利用协程休眠的方式去控制协程的执行顺序是不可取的，因为这样的预测永远无法 100% 如你所愿。如果需要控制协程的同步，我们会在下面讲到 ``channel`` 即管道或信道。




#### 巨人的肩膀：

[浅谈协程和Go语言的Goroutine](https://juejin.cn/post/6844904056918376456)
